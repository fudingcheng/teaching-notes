![](分布式锁.png)

# 1. 锁的概念

## 1.1 作用

多线程下，保证对公共资源操作的正确性。

## 1.2 Sync...本质

* 锁的信息存储在对象头中
* 加锁的本质就是将当前线程的信息在锁对象上打上标记

分布式锁不能使用Sync...原因？

Sync...保证多个线程使用是同一把锁

## 1.3 分布式下锁实现的思路

将锁标记设置在公共的位置

1. 数据库
2. Zookeeper
3. Redis

# 2. 数据库实现分布式锁

## 2.1 加锁步骤

1. 线程在对公共资源进行写操作时，首先获得锁
2. 成功获得锁，操作公共资源
3. 没有获得锁，一直在循环不断尝试再次获得锁，直到拿到锁位置
   1. 非阻塞锁
   2. 超时锁

## 2.2 获得锁步骤

1. 查询数据库中锁的标记
2. 判断，如果有线程已经获得锁
   1. 判断，是不是当前线程
      1. 如果是，重入锁
      2. 如果不是，证明别的线程正在用有锁，直接返回false
3. 判断，没有线程获得锁
   1. 给数据库中插入一条记录即可，代表用有锁。

## 2.3 解锁的步骤

1. 查询数据库中锁是否存在
2. 如果有锁，判断是否是当前线程用有锁
   1. 是，判断重入锁的count>1
      1. 将count-1更新到数据库
      2. count<=1,执行delete语句，删除锁
   2. 不是当线程的锁，直接返回false
3. 没有锁，不需要解锁，直接返回false

---

* 数据库实现分布式锁是悲观锁，适用于同步资源在数据库外部。如果同步资源是在数据库中，可以使用数据库行级锁（for update）。

* 数据库分布式锁由于是悲观锁，所以性能不高，可以使用数据库乐观锁（在表中添加版本号字段，实现原理类似于CAS算法）替代

# 3. Zookeeper

## 3.1 加锁

1. 当前线程在zk中创建临时节点
2. 判断自己创建的节点是不是第一个节点
   1. 是第一个，代表获得锁
   2. 不是第一个，代表未获得锁
      1. 获得前一个节点，并且注册watcher,监控前一个节点的状态

## 3.2 解锁

1. 删除当前线程创建的节点即可
2. 后面的线程自动被触发取抢锁

## 3.3 锁的特点

节点是临时有序节点，保证

1. 不会有死锁发生，因为当zk服务器一旦和客户端的通讯的session挂点，那么zk服务器就会删除锁
2. 节点有序保证锁的公平性

# 4. Redis分布式锁实现

## 4.1 使用命令

setnx key value ex 超时时间 nx

可以使用Jedis发送命令到redis

​	返回值是1，代表获得锁

​	返回值是0，代表没有获得锁

## 4.2 Redission

lock()

unLock()